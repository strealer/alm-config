# Vector configuration for Strealer ALM edge devices
# Optimized for Raspberry Pi 4 (Resource Constrained)

api:
  enabled: true
  address: "0.0.0.0:8686"

# ============================================================================
# SOURCES
# ============================================================================

sources:
  nginx_access:
    type: file
    include: ["/var/log/nginx/access*.log"]
    read_from: end
    max_line_bytes: 102400

  nginx_error:
    type: file
    include: ["/var/log/nginx/error*.log"]
    read_from: end
    max_line_bytes: 102400

  docker_containers:
    type: docker_logs
    docker_host: "unix:///var/run/docker.sock"
    include_containers: ["alm_arm64", "alm_telemetry", "alm_init"]
    exclude_containers: []
    partial_event_marker_field: "_partial"
    auto_partial_merge: true

  system_logs:
    type: journald
    include_units: ["docker", "systemd"]

  # Internal Vector metrics for self-monitoring
  vector_metrics:
    type: internal_metrics
    namespace: vector

# ============================================================================
# TRANSFORMS
# ============================================================================

transforms:
  # Optimize Nginx parsing for CPU efficiency
  parse_nginx_access:
    type: remap
    inputs: ["nginx_access"]
    drop_on_error: true
    reroute_dropped: true
    source: |
      message = string!(.message)
      
      # Try Custom Format (FT/BK)
      if starts_with(message, "FT") || starts_with(message, "BK") {
        # Try Frontend format first (most common)
        parsed, err = parse_regex(message, r'^FT \| (?P<timestamp>[^ ]+) \| (?P<status>\d+) \| (?P<request>[^|]+) \| (?P<cache_status>[^|]+) \| (?P<bytes>\d+)$')
        
        if err != null {
          # Fallback to Backend format
          parsed, err = parse_regex(message, r'^BK \| (?P<timestamp>[^ ]+) \| (?P<status>\d+) \| (?P<request>[^|]+) \| (?P<bytes>\d+)$')
          if err != null {
            abort
          }
          .log_type = "BK"
          .cache_status = "N/A"
        } else {
          .log_type = "FT"
          .cache_status = parsed.cache_status
        }
        
        # Common parsing for custom format
        .timestamp = parse_timestamp!(parsed.timestamp, "%Y-%m-%dT%H:%M:%S%z")
        .status = to_int!(parsed.status)
        .bytes_sent = to_int!(parsed.bytes)
        
        # Extract request parts efficiently
        .request = parsed.request
        req_parts = split(string!(parsed.request), " ", limit: 3)
        .method = req_parts[0]
        .path = req_parts[1]
        .http_version = req_parts[2]
        
      } else {
        # Fallback to Standard Combined Format
        parsed, err = parse_regex(message, r'^(?P<remote_addr>\S+) - (?P<remote_user>\S+) \[(?P<timestamp>[^\]]+)\] "(?P<method>\S+) (?P<path>\S+) (?P<http_version>\S+)" (?P<status>\d+) (?P<bytes_sent>\d+) "(?P<referer>[^"]*)" "(?P<user_agent>[^"]*)"')
        if err != null {
          abort
        }
        
        .timestamp = parse_timestamp!(parsed.timestamp, "%d/%b/%Y:%H:%M:%S %z")
        .status = to_int!(parsed.status)
        .bytes_sent = to_int!(parsed.bytes_sent)
        .method = parsed.method
        .path = parsed.path
        .http_version = parsed.http_version
        .cache_status = "UNKNOWN"
      }
      
      # Efficient categorization (Common)
      path_lower = downcase(string!(.path))
      if contains(path_lower, "/media") {
        .cache_type = "media"
      } else if contains(path_lower, "/player") {
        .cache_type = "player"
      } else if contains(path_lower, "/renderer") {
        .cache_type = "renderer"
      } else {
        .cache_type = "other"
      }

  # Sampling for high-volume logs (keep every 10th success)
  sample_nginx_access:
    type: sample
    inputs: ["parse_nginx_access"]
    rate: 10

  # Add device metadata
  add_metadata:
    type: remap
    inputs: ["sample_nginx_access", "nginx_error", "docker_containers", "system_logs"]
    source: |
      .device_hostname = get_hostname!()
      .device_role = "alm-edge"
      .environment = "production"

  # Generate metrics from logs (for Prometheus)
  log_metrics:
    type: log_to_metric
    inputs: ["add_metadata"]
    metrics:
      - type: counter
        field: status
        name: http_requests_total
        namespace: strealer
        tags:
          status: "{{ status }}"
          method: "{{ method }}"
          cache_status: "{{ cache_status }}"

# ============================================================================
# SINKS
# ============================================================================

sinks:
  loki:
    type: loki
    inputs: ["add_metadata"]
    endpoint: "${LOKI_ENDPOINT:-http://your-loki-server:3100}"
    encoding:
      codec: json
    healthcheck:
      enabled: true
    compression: snappy
    
    # Reduced label cardinality for Loki performance
    labels:
      device: "{{ device_hostname }}"
      role: "alm-edge"
      env: "production"
      log_source: "{{ source_type }}"
      cache_status: "{{ cache_status }}"
    
    # Disk buffering for edge resilience
    buffer:
      type: disk
      max_size: 283115520  # 270MB (increased from 256MB to satisfy min requirement)
      when_full: block
    
    # Optimized batching for edge
    batch:
      max_bytes: 262144  # 256KB
      timeout_secs: 15
      max_events: 1000
    
    # Request limits
    request:
      timeout_secs: 30
      rate_limit_num: 100
      rate_limit_duration_secs: 1
      retry_attempts: 5
    
    # Data durability
    acknowledgements:
      enabled: true

  # Metrics: Push to Prometheus (Remote Write)
  prometheus_remote_write:
    type: prometheus_remote_write
    inputs: ["log_metrics", "vector_metrics"]  # Send generated metrics + internal metrics
    endpoint: "${PROMETHEUS_ENDPOINT:-http://your-prometheus:9090}/api/v1/write"
    default_namespace: "strealer"
    healthcheck:
      enabled: true

  # Expose metrics locally for scraping (optional backup)
  prometheus_exporter:
    type: prometheus_exporter
    inputs: ["log_metrics", "vector_metrics"]
    address: "0.0.0.0:9598"
    default_namespace: "strealer"
